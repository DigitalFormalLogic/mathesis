{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mathesis: Formal Logic Library in Python","text":"<p>Mathesis is a human-friendly Python library for computational formal logic (including mathematical, symbolic, philosophical logic), formal semantics, and theorem proving. It is particularly well-suited for:</p> <ul> <li>Students learning logic and educators teaching it</li> <li>Researchers in fields like logic, philosophy, linguistics, computer science, and many others</li> </ul> <p>Documentation: https://digitalformallogic.github.io/mathesis/</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mathesis\n</code></pre>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Interactive theorem proving for humans (proof assistant)</li> <li>Automated reasoning (theorem prover)</li> <li>Define models and check validity of inferences in the models</li> <li>JupyterLab/Jupyter Notebook support</li> <li>Output formulas/proofs in LaTeX</li> <li>Customizable ASCII/Unicode syntax (like <code>A -&gt; B</code>, <code>A \u2192 B</code>, <code>A \u2283 B</code> for the conditional)</li> </ul>"},{"location":"#supported-logics","title":"Supported logics","text":""},{"location":"#propositional-logics","title":"Propositional logics","text":"Truth Table Tableau Natural Deduction Sequent Calculus Classical logic \u2705 \u2705 \u2705 \u2705 Many-valued logics \u2705 - - - Intuitionistic logic n/a - - \u2705"},{"location":"#in-progress","title":"In Progress","text":"<ul> <li>Modal logics</li> <li>Fuzzy logics</li> <li>Substructural logics</li> <li>Epistemic, doxastic, deontic logics</li> <li>Temporal logics</li> </ul>"},{"location":"#first-order-logics-quantified-predicate-logics","title":"First-order logics (quantified, predicate logics)","text":"Model Tableau Natural Deduction Sequent Calculus Classical logic \u2705 \u2705 - -"},{"location":"#in-progress_1","title":"In Progress","text":"<ul> <li>Many-valued logics</li> <li>Modal logics</li> <li>Intuitionistic logic</li> <li>Fuzzy logics</li> <li>Substructural logics</li> <li>Higher-order logics</li> </ul>"},{"location":"#development-status","title":"Development status","text":""},{"location":"#proof-theories","title":"Proof theories","text":"<ul> <li>Tableaux (semantic tableaux, analytic tableaux)<ul> <li> Unsigned tableaux</li> <li> Signed tableaux</li> </ul> </li> <li>Hilbert systems<ul> <li> Hilbert systems</li> </ul> </li> <li>Natural deduction<ul> <li> Generic natural deduction</li> <li> Gentzen-style natural deduction (Output)</li> <li> Fitch-style natural deduction</li> </ul> </li> <li>Sequent calculi (Gentzen-style sequent calculi)<ul> <li> Two-sided sequent calculi</li> <li> Hilbert systems in sequent calculus</li> <li> Natural deduction in sequent calculus</li> </ul> </li> </ul>"},{"location":"#semantics","title":"Semantics","text":"<ul> <li> Truth tables</li> <li> Set-theoretic models</li> <li> Possible world semantics (Kripke semantics)</li> <li> Algebraic semantics</li> <li> Game-theoretic semantics</li> <li> Category-theoretic semantics</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"alternatives/","title":"Alternatives","text":""},{"location":"alternatives/#nltk","title":"NLTK","text":"<p>NLTK is a Python library for Natural Language Processing, but it includes some logic-related modules:</p> <ul> <li>NLTK :: Sample usage for logic</li> <li>NLTK :: Sample usage for inference</li> <li>NLTK :: Sample usage for resolution</li> <li>NLTK :: Sample usage for nonmonotonic</li> </ul>"},{"location":"alternatives/#pros","title":"Pros","text":"<ul> <li>A mature library with a large community</li> <li>Advanced features</li> </ul>"},{"location":"alternatives/#cons","title":"Cons","text":"<ul> <li>Less flexible syntax</li> <li>Fewer proof methods supported</li> <li>No support for LaTeX output</li> </ul>"},{"location":"alternatives/#others-to-be-added","title":"Others (to be added)","text":"<ul> <li>PyLogics</li> <li>Logic - SymPy</li> <li>tt: logical tools for logic</li> <li>FLiP</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Open an issue or submit a pull request on GitHub digitalformallogic/mathesis.</p>"},{"location":"install/","title":"Installation","text":"<p>Mathesis can be installed from PyPI with pip:</p> <pre><code>pip install mathesis\n</code></pre> <p>To upgrade, add the <code>-U</code> flag:</p> <pre><code>pip install -U mathesis\n</code></pre> <p>Next steps:</p> <ul> <li>To use Mathesis with JupyterLab/Jupyter Notebook, see Use with JupyterLab/Jupyter Notebook</li> </ul>"},{"location":"jupyter/","title":"Use with JupyterLab/Jupyer Notebook","text":"<p>Mathesis works well with JupyterLab and Jupyter notebooks. This is an example of a notebook that uses Mathesis.</p> In\u00a0[1]: Copied! <pre>from IPython.display import display, Math\n</pre> from IPython.display import display, Math In\u00a0[2]: Copied! <pre>from mathesis.deduction.sequent_calculus import SequentTree, rules\nfrom mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\npremises = grammar.parse([\"\u00acA\", \"A\u2228B\"])\nconclusions = grammar.parse([\"B\"])\n</pre> from mathesis.deduction.sequent_calculus import SequentTree, rules from mathesis.grammars import BasicGrammar  grammar = BasicGrammar() premises = grammar.parse([\"\u00acA\", \"A\u2228B\"]) conclusions = grammar.parse([\"B\"]) In\u00a0[3]: Copied! <pre>st = SequentTree(premises, conclusions)\n\nMath(st[1].sequent.latex())\n</pre>  st = SequentTree(premises, conclusions)  Math(st[1].sequent.latex()) Out[3]:  $\\displaystyle \\neg A, A \\lor B \\Rightarrow B$  In\u00a0[4]: Copied! <pre>st.apply(st[1], rules.Negation.Left())\nprint(st.tree())\n</pre> st.apply(st[1], rules.Negation.Left()) print(st.tree()) <pre>\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6\n\n</pre> In\u00a0[5]: Copied! <pre>st.apply(st[5], rules.Disjunction.Left())\nprint(st.tree())\n</pre> st.apply(st[5], rules.Disjunction.Left()) print(st.tree()) <pre>\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n</pre> In\u00a0[6]: Copied! <pre>st.apply(st[9], rules.Weakening.Right())\nprint(st.tree())\n</pre> st.apply(st[9], rules.Weakening.Right()) print(st.tree()) <pre>\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n</pre> In\u00a0[7]: Copied! <pre>st.apply(st[11], rules.Weakening.Right())\nprint(st.tree())\n</pre> st.apply(st[11], rules.Weakening.Right()) print(st.tree()) <pre>\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12 [wR]\n        \u2514\u2500\u2500 B 15 \u21d2 B 16\n\n</pre> In\u00a0[8]: Copied! <pre>print(st.latex())\n</pre> print(st.latex()) <pre>\\begin{prooftree}\n\\AxiomC{$A \\Rightarrow A$}\n\\RightLabel{$wR}\n\\UnaryInfC{$A \\Rightarrow A, B$}\n\\AxiomC{$B \\Rightarrow B$}\n\\RightLabel{$wR}\n\\UnaryInfC{$B \\Rightarrow A, B$}\n\\RightLabel{$\\lor$L}\n\\BinaryInfC{$A \\lor B \\Rightarrow A, B$}\n\\RightLabel{$\\neg$L}\n\\UnaryInfC{$\\neg A, A \\lor B \\Rightarrow B$}\n\\end{prooftree}\n</pre>"},{"location":"usage/automated-reasoning/","title":"Automated Reasoning","text":"<p>Mathesis provides simple solvers (reasoners, provers) based on truth table method and on tableau method.</p>"},{"location":"usage/automated-reasoning/#reasoning-in-propositional-logic","title":"Reasoning in propositional logic","text":""},{"location":"usage/automated-reasoning/#solvers-based-on-truth-table-method","title":"Solvers based on truth table method","text":"<p>See Truth tables.</p>"},{"location":"usage/automated-reasoning/#solvers-based-on-tableau-method","title":"Solvers based on tableau method","text":"<p><code>mathesis.solvers.ClassicalSolver</code> is a solver for classical propositional logic based on tableau method.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.solvers import ClassicalSolver\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"((A \u2192 B)\u2227(A \u2192 C)) \u2192 (A \u2192 (B\u2227C))\")\nsol = ClassicalSolver().solve([], [fml])\n\nprint(sol.htree())\nprint(f\"Valid: {sol.is_valid()}\")\n</code></pre> <pre><code>\u00ac(((A\u2192B)\u2227(A\u2192C))\u2192(A\u2192(B\u2227C))) 1\n\u2514\u2500\u2500 (A\u2192B)\u2227(A\u2192C) 2\n    \u2514\u2500\u2500 \u00ac(A\u2192(B\u2227C)) 3\n        \u2514\u2500\u2500 A\u2192B 4\n            \u2514\u2500\u2500 A\u2192C 5\n                \u2514\u2500\u2500 A 6\n                    \u2514\u2500\u2500 \u00ac(B\u2227C) 7\n                        \u251c\u2500\u2500 \u00acA 8 \u00d7\n                        \u2514\u2500\u2500 B 9\n                            \u251c\u2500\u2500 \u00acA 10 \u00d7\n                            \u2514\u2500\u2500 C 11\n                                \u251c\u2500\u2500 \u00acB 12 \u00d7\n                                \u2514\u2500\u2500 \u00acC 13 \u00d7\n\nValid: True\n</code></pre>"},{"location":"usage/grammars/","title":"Formulas and Grammars","text":""},{"location":"usage/grammars/#parsing-formulas","title":"Parsing formulas","text":"<p>In Mathesis, formulas are represented as objects. Formulas are parsed from strings using grammars (languages, syntax). <code>mathesis.grammars.BasicGrammar</code> is a basic grammar with a standard set of symbols for propositional and quantified logic:</p> <ul> <li><code>\u00ac</code> for negation, <code>\u2227</code> for conjunction, <code>\u2228</code> for disjunction, <code>\u2192</code> for conditional.</li> <li>Arbitrary symbols are allowed for atomic formulas.</li> </ul> <p>For example, <code>\u00ac(A\u2192C)</code> is parsed as a negation of a conditional of two atomic formulas <code>A</code> and <code>C</code>.</p> <pre><code>from mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"\u00ac(A\u2192C)\")\n\nprint(fml, repr(fml))\n</code></pre> <pre><code>\u00ac(A\u2192C) Neg[Cond[Atom[A], Atom[C]]]\n</code></pre> <p>The <code>symbols</code> option allows you to customize some symbols used in the grammar.</p> <pre><code>from mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar(symbols={\"conditional\": \"\u2283\"})\n\nfml = grammar.parse(\"\u00ac(A\u2283C)\")\n\nprint(fml, repr(fml))\n</code></pre> <pre><code>\u00ac(A\u2192C) Neg[Cond[Atom[A], Atom[C]]]\n</code></pre> <p>It accepts a list of formulas as well.</p> <pre><code>from mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\n\nfmls = grammar.parse([\"\u00ac(A\u2192C)\", \"B\u2228\u00acB\", \"(((A\u2227B)))\"])\n\nprint([str(fml) for fml in fmls], repr(fmls))\n</code></pre> <pre><code>['\u00ac(A\u2192C)', 'B\u2228\u00acB', 'A\u2227B'] [Neg[Cond[Atom[A], Atom[C]]], Disj[Atom[B], Neg[Atom[B]]], Conj[Atom[A], Atom[B]]]\n</code></pre>"},{"location":"usage/grammars/#advanced","title":"Advanced","text":""},{"location":"usage/grammars/#constructing-formula-objects-directly","title":"Constructing formula objects directly","text":"<p><code>mathesis.forms.Formula</code> is the base class for all formulas.</p> <pre><code>from mathesis.forms import Negation, Conjunction, Disjunction, Conditional, Atom\n\nfml = Negation(Conditional(Atom(\"A\"), Atom(\"C\")))\n\nprint(fml, repr(fml))\n</code></pre> <pre><code>\u00ac(A\u2192C) Neg[Cond[Atom[A], Atom[C]]]\n</code></pre> <p>New connectives can be defined by subclassing <code>Formula</code>.</p>"},{"location":"usage/grammars/#custom-grammars","title":"Custom grammars","text":"<p>While there is no restriction in the way that a formula string is translated into a formula object, by default Mathesis uses <code>lark</code> for parsing. Using lark, you can define arbitrary grammars in EBNF (Extended Backus-Naur Form) notation. For example, here is a simple grammar for first-order classical logic:</p> <pre><code>from mathesis.grammars import Grammar\n\nclass MyGrammar(Grammar):\n    grammar_rules = r\"\"\"\n?fml: conjunction\n    | disjunction\n    | conditional\n    | negation\n    | universal\n    | particular\n    | atom\n    | _subfml\n\nPREDICATE: /\\w+/ | \"\u22a4\" | \"\u22a5\"\nTERM: /\\w+/\n\natom : PREDICATE (\"(\" TERM (\",\" TERM)* \")\")?\nnegation : \"\u00ac\" _subfml\nconjunction : (conjunction | _subfml) \"\u2227\" _subfml\ndisjunction : (disjunction | _subfml) \"\u2228\" _subfml\nconditional : _subfml \"\u2192\" _subfml\n\n_unary : negation | necc | poss | universal | particular\n_subfml : \"(\" fml \")\" | _unary | atom\n\n%import common.WS\n%ignore WS\n\"\"\".lstrip()\n</code></pre>"},{"location":"usage/kripke/","title":"Possible world (Kripke) semantics","text":"<p>WIP</p>"},{"location":"usage/models/","title":"Set-theoretic Models","text":"In\u00a0[1]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.model import Model\n\ngrammar = BasicGrammar(symbols={\"conditional\": \"\u2192\"})\n\nmodel = Model(\n    domain={\"a\", \"b\", \"c\"},\n    constants={\n        \"a\": \"a\",\n        \"b\": \"b\",\n    },\n    predicates={\n        \"P\": {\"a\", \"b\"},\n        \"Q\": {\"a\"},\n        \"R\": {(\"a\", \"b\"), (\"c\", \"a\")},\n    },\n)\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.model import Model  grammar = BasicGrammar(symbols={\"conditional\": \"\u2192\"})  model = Model(     domain={\"a\", \"b\", \"c\"},     constants={         \"a\": \"a\",         \"b\": \"b\",     },     predicates={         \"P\": {\"a\", \"b\"},         \"Q\": {\"a\"},         \"R\": {(\"a\", \"b\"), (\"c\", \"a\")},     }, ) <p><code>model.valuate()</code> takes a formula and a variable assignment and returns the truth value of the formula in the model.</p> In\u00a0[2]: Copied! <pre>fml = grammar.parse(\"P(a) \u2192 R(x, b)\")\nmodel.valuate(fml, variable_assignment={\"x\": \"c\"})\n</pre> fml = grammar.parse(\"P(a) \u2192 R(x, b)\") model.valuate(fml, variable_assignment={\"x\": \"c\"}) Out[2]: <pre>0</pre> In\u00a0[3]: Copied! <pre>model.valuate(fml, variable_assignment={\"x\": \"a\"})\n</pre> model.valuate(fml, variable_assignment={\"x\": \"a\"}) Out[3]: <pre>1</pre> <p><code>model.validates()</code> takes premises and conclusions and returns whether the model validates the inference.</p> In\u00a0[4]: Copied! <pre>fml = grammar.parse(\"\u2200x(\u2203y((Q(x)\u2228Q(b))\u2192R(x, y)))\")\nmodel.validates(premises=[], conclusions=[fml])\n</pre> fml = grammar.parse(\"\u2200x(\u2203y((Q(x)\u2228Q(b))\u2192R(x, y)))\") model.validates(premises=[], conclusions=[fml]) Out[4]: <pre>True</pre>"},{"location":"usage/models/#models","title":"Models\u00b6","text":"<p>Models can be defined using <code>Model</code> class in <code>mathesis.semantics.model</code>. The class takes four arguments:</p> <ul> <li><code>domain</code>: domain of objects of the model</li> <li><code>constants</code>: a dictionary mapping constant symbols to objects</li> <li><code>predicates</code>: a dictionary mapping predicate symbols to their extensions</li> <li><code>functions</code> (Optional): a dictionary mapping function symbols to functions over the domain</li> </ul>"},{"location":"usage/models/#countermodel-construction","title":"Countermodel construction\u00b6","text":"<p>WIP</p>"},{"location":"usage/natural-deduction/","title":"Proof in Natural Deduction","text":""},{"location":"usage/natural-deduction/#introduction","title":"Introduction","text":"<p>In Mathesis, a state of a natural deduction proof (and its subproofs) consists of the premises and the conclusion that are available to the (sub)proof at a given step. A state is displayed as <code>&lt;premises&gt; \u21d2 &lt;conclusion&gt;</code>.</p> <p>Intuitively, the formulas on the left side of <code>\u21d2</code> are what to come to the upper part of the final (sub)proof, and those on the right side of <code>\u21d2</code> are what to come to the lower part of the final (sub)proof.</p> <p>Natural deduction is a proof system that consists of elimination rules and introduction rules. In Mathesis,</p> <ul> <li>you can apply an elimination rule up-to-down to the premises of a (sub)proof to obtain new premises.</li> <li>Similarly, you can apply an introduction rule down-to-up to the conclusion of a (sub)proof and convert it into new subproofs.</li> </ul> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.natural_deduction import NDTree, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2228B\", \"B\u2192C\"])\nconclusion = grammar.parse(\"A\u2228C\")\nderiv = NDTree(premises, conclusion)\nprint(deriv.tree())\n\nderiv.apply(deriv[1], rules.Disjunction.Elim())\nprint(deriv.tree())\n\nderiv.apply(deriv[7], rules.Disjunction.Intro(\"left\"))\nprint(deriv.tree())\n\nderiv.apply(deriv[10], rules.Conditional.Elim())\nprint(deriv.tree())\n\nderiv.apply(deriv[25], rules.Disjunction.Intro(\"right\"))\nprint(deriv.tree())\n</code></pre> <pre><code>A\u2228B 1, B\u2192C 2 \u21d2 A\u2228C 3\n\nA\u2228B 1, B\u2192C 2 \u21d2 A\u2228C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A\u2228B 5, B\u2192C 6 \u21d2 A\u2228C 7\n\u2514\u2500\u2500 B 8, A\u2228B 9, B\u2192C 10 \u21d2 A\u2228C 11\n\nA\u2228B 1, B\u2192C 2 \u21d2 A\u2228C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A\u2228B 5, B\u2192C 6 \u21d2 A\u2228C 7 [\u2228I]\n\u2502   \u2514\u2500\u2500 A 13, A\u2228B 14, B\u2192C 15 \u21d2 A 12\n\u2514\u2500\u2500 B 8, A\u2228B 9, B\u2192C 10 \u21d2 A\u2228C 11\n\nA\u2228B 1, B\u2192C 2 \u21d2 A\u2228C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A\u2228B 5, B\u2192C 6 \u21d2 A\u2228C 7 [\u2228I]\n\u2502   \u2514\u2500\u2500 A 13, A\u2228B 14, B\u2192C 15 \u21d2 A 12\n\u2514\u2500\u2500 B 8, A\u2228B 9, B\u2192C 10 \u21d2 A\u2228C 11 [\u2192E]\n    \u251c\u2500\u2500 B 17, A\u2228B 18, B\u2192C 19 \u21d2 B 16\n    \u2514\u2500\u2500 C 21, B 22, A\u2228B 23, B\u2192C 24 \u21d2 A\u2228C 25\n\nA\u2228B 1, B\u2192C 2 \u21d2 A\u2228C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A\u2228B 5, B\u2192C 6 \u21d2 A\u2228C 7 [\u2228I]\n\u2502   \u2514\u2500\u2500 A 13, A\u2228B 14, B\u2192C 15 \u21d2 A 12\n\u2514\u2500\u2500 B 8, A\u2228B 9, B\u2192C 10 \u21d2 A\u2228C 11 [\u2192E]\n    \u251c\u2500\u2500 B 17, A\u2228B 18, B\u2192C 19 \u21d2 B 16\n    \u2514\u2500\u2500 C 21, B 22, A\u2228B 23, B\u2192C 24 \u21d2 A\u2228C 25 [\u2228I]\n        \u2514\u2500\u2500 C 27, B 28, A\u2228B 29, B\u2192C 30 \u21d2 C 26\n</code></pre>"},{"location":"usage/natural-deduction/#render-as-gentzen-style-proof","title":"Render as Gentzen-style Proof","text":"<p>(WIP) Mathesis has an experimental support for rendering a natural deduction proof as a Gentzen-style proof or its LaTeX code.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.natural_deduction import NDTree, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2228B\", \"B\u2192C\"])\nconclusion = grammar.parse(\"A\u2228C\")\nderiv = NDTree(premises, conclusion)\nprint(deriv.tree(number=False))\n\nderiv.apply(deriv[1], rules.Disjunction.Elim())\nderiv.apply(deriv[7], rules.Disjunction.Intro(\"left\"))\nderiv.apply(deriv[10], rules.Conditional.Elim())\nderiv.apply(deriv[25], rules.Disjunction.Intro(\"right\"))\n\nprint(deriv.tree(style=\"gentzen\"))\n\nprint(deriv.latex())\n</code></pre> <pre><code>A\u2228B, B\u2192C \u21d2 A\u2228C\n\nA\u2228C\n\u251c\u2500\u2500 A\u2228C\n\u2502   \u2514\u2500\u2500 A\n\u251c\u2500\u2500 A\u2228C\n\u2502   \u2514\u2500\u2500 C\n\u2502       \u251c\u2500\u2500 B\n\u2502       \u2514\u2500\u2500 B\u2192C\n\u2514\u2500\u2500 A\u2228B\n\n\\begin{prooftree}\n\\AxiomC{$A$}\n\\RightLabel{$\\lor$I}\n\\UnaryInfC{$A \\lor C$}\n\\AxiomC{$B$}\n\\RightLabel{$\\to$E}\n\\AxiomC{$B \\to C$}\n\\BinaryInfC{$C$}\n\\RightLabel{$\\lor$I}\n\\UnaryInfC{$A \\lor C$}\n\\RightLabel{$\\lor$E}\n\\AxiomC{$A \\lor B$}\n\\TrinaryInfC{$A \\lor C$}\n\\end{prooftree}\n</code></pre> \\[ \\begin{prooftree} \\AxiomC{$A$} \\RightLabel{$\\lor$I} \\UnaryInfC{$A \\lor C$} \\AxiomC{$B$} \\RightLabel{$\\to$E} \\AxiomC{$B \\to C$} \\BinaryInfC{$C$} \\RightLabel{$\\lor$I} \\UnaryInfC{$A \\lor C$} \\RightLabel{$\\lor$E} \\AxiomC{$A \\lor B$} \\TrinaryInfC{$A \\lor C$} \\end{prooftree} \\]"},{"location":"usage/natural-deduction/#render-as-fitch-style-proof","title":"Render as Fitch-style Proof","text":"<p>WIP</p>"},{"location":"usage/natural-deduction/#render-as-suppes-lemmon-style-proof","title":"Render as Suppes-Lemmon-style Proof","text":"<p>WIP</p>"},{"location":"usage/natural-deduction/#render-as-sequent-calculus-proof","title":"Render as Sequent Calculus Proof","text":"<p>WIP</p>"},{"location":"usage/sequent-calculi/","title":"Proof in Sequent Calculus","text":"<p>Sequent calculus (plural: calculi) is a formal proof system based on sequents, which normally are expressions of the form \\(\\Gamma \\vdash \\Delta\\), where \\(\\Gamma\\) and \\(\\Delta\\) are lists or sets of formulas.</p>"},{"location":"usage/sequent-calculi/#sequent-trees-and-applications-of-rules","title":"Sequent trees and applications of rules","text":"<p><code>mathesis.deduction.sequent_calculus.SequentTree</code> is a class for sequent trees (proof trees, proof diagrams). It is initialized with an inference, given as a list of premises and of conclusions. Rules are applied to a sequent in a sequent tree with <code>st.apply(node, rule)</code> where <code>st</code> is a sequent tree.</p> <pre><code>from mathesis.deduction.sequent_calculus import SequentTree, rules\nfrom mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\npremises = grammar.parse([\"\u00acA\", \"A\u2228B\"])\nconclusions = grammar.parse([\"B\"])\n\nst = SequentTree(premises, conclusions)\n\nprint(st.tree())\nst.apply(st[1], rules.Negation.Left())\nprint(st.tree())\nst.apply(st[5], rules.Disjunction.Left())\nprint(st.tree())\nst.apply(st[9], rules.Weakening.Right())\nprint(st.tree())\nst.apply(st[12], rules.Weakening.Right())\nprint(st.tree())\n</code></pre> <pre><code>\u00acA 1, A\u2228B 2 \u21d2 B 3\n\n\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6\n\n\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12 [wR]\n        \u2514\u2500\u2500 B 15 \u21d2 A 16\n</code></pre>"},{"location":"usage/sequent-calculi/#render-the-proof-in-latex","title":"Render the proof in LaTeX","text":"<p>A sequent tree object can be rendered in LaTeX with <code>st.latex()</code>. The LaTeX output uses a <code>prooftree</code> environment of <code>bussproofs</code> package. MathJax supports <code>bussproofs</code> package, so you can render the LaTeX output on a Web page.</p> <pre><code>from mathesis.deduction.sequent_calculus import SequentTree, rules\nfrom mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\npremises = grammar.parse([\"\u00acA\", \"A\u2228B\"])\nconclusions = grammar.parse([\"B\"])\n\nst = SequentTree(premises, conclusions)\n\nprint(st.tree())\nprint(st.latex(number=False), \"\\n\")\n\nst.apply(st[1], rules.Negation.Left())\n# print(st.tree())\nst.apply(st[5], rules.Disjunction.Left())\n# print(st.tree())\nst.apply(st[9], rules.Weakening.Right())\n# print(st.tree())\nst.apply(st[12], rules.Weakening.Right())\nprint(st.tree())\nprint(st.latex(number=False))\n</code></pre> <pre><code>\u00acA 1, A\u2228B 2 \u21d2 B 3\n\n\\begin{prooftree}\n\\AxiomC{$\\neg A, A \\lor B \\Rightarrow B$}\n\\end{prooftree} \n\n\u00acA 1, A\u2228B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A\u2228B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12 [wR]\n        \u2514\u2500\u2500 B 15 \u21d2 A 16\n\n\\begin{prooftree}\n\\AxiomC{$A \\Rightarrow A$}\n\\RightLabel{$wR}\n\\UnaryInfC{$A \\Rightarrow A, B$}\n\\AxiomC{$B \\Rightarrow A$}\n\\RightLabel{$wR}\n\\UnaryInfC{$B \\Rightarrow A, B$}\n\\RightLabel{$\\lor$L}\n\\BinaryInfC{$A \\lor B \\Rightarrow A, B$}\n\\RightLabel{$\\neg$L}\n\\UnaryInfC{$\\neg A, A \\lor B \\Rightarrow B$}\n\\end{prooftree}\n</code></pre> \\[ \\begin{prooftree} \\AxiomC{$\\neg A, A \\lor B \\Rightarrow B$} \\end{prooftree} \\] \\[ \\begin{prooftree} \\AxiomC{$A \\Rightarrow A$} \\RightLabel{wR} \\UnaryInfC{$A \\Rightarrow A, B$} \\AxiomC{$B \\Rightarrow A$} \\RightLabel{wR} \\UnaryInfC{$B \\Rightarrow A, B$} \\RightLabel{$\\lor$L} \\BinaryInfC{$A \\lor B \\Rightarrow A, B$} \\RightLabel{$\\neg$L} \\UnaryInfC{$\\neg A, A \\lor B \\Rightarrow B$} \\end{prooftree} \\]"},{"location":"usage/tableaux/","title":"Proof in Tableau","text":"<p>Semantic tableau (plural: tableaux) is a decision/proof procedure for propositional and quantified logics.</p>"},{"location":"usage/tableaux/#unsigned-tableaux","title":"Unsigned tableaux","text":"<p><code>mathesis.deduction.tableau.Tableau</code> is a class for unsigned tableaux. It is initialized with an inference, given as a list of premises and of conclusions.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import Tableau\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2192B\", \"B\u2192C\"])\nconclusions = grammar.parse([\"A\u2192C\"])\ntab = Tableau(premises, conclusions)\n\nprint(tab.htree())\n</code></pre> <pre><code>A\u2192B 1\n\u2514\u2500\u2500 B\u2192C 2\n    \u2514\u2500\u2500 \u00ac(A\u2192C) 3\n</code></pre> <p>A tableau is a tree of nodes, each node being a formula. Mathesis automatically indexes the nodes, so that you can access them by their index. You can apply a rule to a node of tableau with <code>tab.apply(node, rule)</code> where <code>tab</code> is a tableau:</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import Tableau, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2192B\", \"B\u2192C\"])\nconclusions = grammar.parse([\"A\u2192C\"])\ntab = Tableau(premises, conclusions)\n\nprint(tab.htree())\nprint(f\"Closed: {tab.is_closed()}\\n\")\n\ntab.apply(tab[3], rules.NegatedConditionalRule())\nprint(tab.htree())\ntab.apply(tab[1], rules.ConditionalRule())\nprint(tab.htree())\ntab.apply(tab[2], rules.ConditionalRule())\nprint(tab.htree())\n\nprint(f\"Closed: {tab.is_closed()}\")\n</code></pre> <pre><code>A\u2192B 1\n\u2514\u2500\u2500 B\u2192C 2\n    \u2514\u2500\u2500 \u00ac(A\u2192C) 3\n\nClosed: False\n\nA\u2192B 1\n\u2514\u2500\u2500 B\u2192C 2\n    \u2514\u2500\u2500 \u00ac(A\u2192C) 3\n        \u2514\u2500\u2500 A 4\n            \u2514\u2500\u2500 \u00acC 5\n\nA\u2192B 1\n\u2514\u2500\u2500 B\u2192C 2\n    \u2514\u2500\u2500 \u00ac(A\u2192C) 3\n        \u2514\u2500\u2500 A 4\n            \u2514\u2500\u2500 \u00acC 5\n                \u251c\u2500\u2500 \u00acA 6 \u00d7\n                \u2514\u2500\u2500 B 7\n\nA\u2192B 1\n\u2514\u2500\u2500 B\u2192C 2\n    \u2514\u2500\u2500 \u00ac(A\u2192C) 3\n        \u2514\u2500\u2500 A 4\n            \u2514\u2500\u2500 \u00acC 5\n                \u251c\u2500\u2500 \u00acA 6 \u00d7\n                \u2514\u2500\u2500 B 7\n                    \u251c\u2500\u2500 \u00acB 8 \u00d7\n                    \u2514\u2500\u2500 C 9 \u00d7\n\nClosed: True\n</code></pre> <p>A branch is a path from the root to a leaf of the tableau. A branch is closed if it contains a contradiction (i.e., contradictory formulas.) The tableau is closed if all branches are closed.</p>"},{"location":"usage/tableaux/#signed-tableaux","title":"Signed tableaux","text":"<p>A signed tableau is a tableau where each node is signed with a truth value.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import SignedTableau, signed_rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2192B\", \"B\u2192C\"])\nconclusions = grammar.parse([\"A\u2192C\"])\ntab = SignedTableau(premises, conclusions)\n\nprint(tab.htree())\n</code></pre> <pre><code>True A\u2192B 1\n\u2514\u2500\u2500 True B\u2192C 2\n    \u2514\u2500\u2500 False A\u2192C 3\n</code></pre>"},{"location":"usage/tableaux/#first-order-logic","title":"First-order logic","text":"<p>In first-order logic, the rules extend to quantifiers as follows:</p>"},{"location":"usage/tableaux/#unsigned-tableaux_1","title":"Unsigned tableaux","text":"<ul> <li><code>NegatedParticularRule</code></li> <li><code>NegatedUniversalRule</code></li> <li><code>UniversalInstantiationRule</code></li> <li><code>ParticularInstantiationRule</code></li> </ul> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import Tableau, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"P(a)\", \"\u2200x(P(x)\u2192Q(x))\"])\nconclusions = grammar.parse([\"Q(a)\"])\ntab = Tableau(premises, conclusions)\n\nprint(tab.htree())\nprint(f\"Closed: {tab.is_closed()}\\n\")\n\ntab.apply(tab[2], rules.UniversalInstantiationRule(replacing_term=\"a\"))\nprint(tab.htree())\n\ntab.apply(tab[4], rules.ConditionalRule())\nprint(tab.htree())\n\nprint(f\"Closed: {tab.is_closed()}\\n\")\n</code></pre> <pre><code>P(a) 1\n\u2514\u2500\u2500 \u2200x(P(x)\u2192Q(x)) 2\n    \u2514\u2500\u2500 \u00acQ(a) 3\n\nClosed: False\n\nP(a) 1\n\u2514\u2500\u2500 \u2200x(P(x)\u2192Q(x)) 2\n    \u2514\u2500\u2500 \u00acQ(a) 3\n        \u2514\u2500\u2500 P(a)\u2192Q(a) 4\n\nP(a) 1\n\u2514\u2500\u2500 \u2200x(P(x)\u2192Q(x)) 2\n    \u2514\u2500\u2500 \u00acQ(a) 3\n        \u2514\u2500\u2500 P(a)\u2192Q(a) 4\n            \u251c\u2500\u2500 \u00acP(a) 5 \u00d7\n            \u2514\u2500\u2500 Q(a) 6 \u00d7\n\nClosed: True\n</code></pre>"},{"location":"usage/tableaux/#signed-tableaux_1","title":"Signed tableaux","text":"<p>WIP</p>"},{"location":"usage/tableaux/#further-reading","title":"Further reading","text":"<p>See Automated reasoning for automated reasoning with tableaux.</p>"},{"location":"usage/truth-tables/","title":"Truth Tables","text":"In\u00a0[1]: Copied! <pre>from mathesis.system.classical.truth_table import ConditionalClause\n\nconditional_clause = ConditionalClause()\nconditional_clause\n</pre> from mathesis.system.classical.truth_table import ConditionalClause  conditional_clause = ConditionalClause() conditional_clause Out[1]: P Q Conditional(P, Q) 1 1 1 1 0 0 0 1 1 0 0 1 <p>Outside Jupyer, you get a plain text table:</p> In\u00a0[2]: Copied! <pre>print(conditional_clause)\n</pre> print(conditional_clause) <pre>P        Q        Conditional(P, Q)        \n1        1                1                \n1        0                0                \n0        1                1                \n0        0                1                \n</pre> In\u00a0[3]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import ClassicalTruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"(\u00acP\u2227(P\u2228Q))\u2192Q\")\n\ntable = ClassicalTruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import ClassicalTruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"(\u00acP\u2227(P\u2228Q))\u2192Q\")  table = ClassicalTruthTable(fml) table Out[3]: P Q \u00acP P\u2228Q \u00acP\u2227(P\u2228Q) (\u00acP\u2227(P\u2228Q))\u2192Q 0 0 1 0 0 1 0 1 1 1 1 1 1 0 0 1 0 1 1 1 0 1 0 1 <p><code>table.is_valid()</code> just returns whether the formula is valid.</p> In\u00a0[4]: Copied! <pre>f\"Valid: {table.is_valid()}\"\n</pre> f\"Valid: {table.is_valid()}\" Out[4]: <pre>'Valid: True'</pre> In\u00a0[5]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import K3TruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"A\u2228\u00acA\")\n\ntable = K3TruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import K3TruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"A\u2228\u00acA\")  table = K3TruthTable(fml) table Out[5]: A \u00acA A\u2228\u00acA i i i 0 1 1 1 0 1 In\u00a0[6]: Copied! <pre>f\"Valid: {table.is_valid()}\"\n</pre> f\"Valid: {table.is_valid()}\" Out[6]: <pre>'Valid: False'</pre> In\u00a0[7]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import L3TruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"A\u2192A\")\n\ntable = L3TruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import L3TruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"A\u2192A\")  table = L3TruthTable(fml) table Out[7]: A A\u2192A i 1 0 1 1 1 In\u00a0[8]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import LPTruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")\n\ntable = LPTruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import LPTruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")  table = LPTruthTable(fml) table Out[8]: A \u00acA A\u2227\u00acA (A\u2227\u00acA)\u2192A 0 1 0 1 1 0 0 1 i i i i In\u00a0[9]: Copied! <pre>f\"Valid: {table.is_valid()}\"\n</pre> f\"Valid: {table.is_valid()}\" Out[9]: <pre>'Valid: True'</pre> In\u00a0[10]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import FDETruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")\n\ntable = FDETruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import FDETruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")  table = FDETruthTable(fml) table Out[10]: A \u00acA A\u2227\u00acA (A\u2227\u00acA)\u2192A i i i i 0 1 0 1 b b b b 1 0 0 1"},{"location":"usage/truth-tables/#truth-tables","title":"Truth tables\u00b6","text":""},{"location":"usage/truth-tables/#show-truth-tables-for-connectives","title":"Show truth tables for connectives\u00b6","text":"<p>Truth functions are defined as clauses in mathesis. You can show the truth tables for the clauses in HTML in JupyerLab/Jupyter Notebook:</p>"},{"location":"usage/truth-tables/#generate-truth-tables-for-classical-logic","title":"Generate truth tables for classical logic\u00b6","text":"<p><code>mathesis.semantics.truth_table.ClassicalTruthTable</code> automatically generates the truth table for a given formula.</p>"},{"location":"usage/truth-tables/#generate-truth-tables-for-many-valued-logics","title":"Generate truth tables for many-valued logics\u00b6","text":"<p>Some many-valued logics are implemented out of the box. They are available from <code>mathesis.semantics.truth_table</code>.</p>"},{"location":"usage/truth-tables/#three-valued-logic-k3-and-3","title":"Three-valued logic K<sub>3</sub> and \u0141<sub>3</sub>\u00b6","text":""},{"location":"usage/truth-tables/#kleenes-k3","title":"Kleene's K<sub>3</sub>\u00b6","text":""},{"location":"usage/truth-tables/#ukasiewiczs-3","title":"\u0141ukasiewicz's \u0141<sub>3</sub>\u00b6","text":""},{"location":"usage/truth-tables/#three-valued-logic-lp","title":"Three-valued logic LP\u00b6","text":""},{"location":"usage/truth-tables/#four-valued-logic-fde","title":"Four-valued logic FDE\u00b6","text":""},{"location":"usage/truth-tables/#use-custom-symbols-for-truth-values","title":"Use custom symbols for truth values\u00b6","text":"<p>Subclasses of <code>ConnectiveClause()</code> and <code>TruthTable()</code> can have <code>truth_value_symbols</code> attribute that is a dictionary mapping internal numeric truth values to arbitrary symbols like \u22a4, \u22a5, T, F, etc.</p>"},{"location":"usage/truth-tables/#define-custom-truth-tables","title":"Define custom truth tables\u00b6","text":"<p>WIP</p>"}]}