{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Mathesis: Formal Logic Library in Python","text":"<p>Mathesis is a human-friendly Python library for computational formal logic (including mathematical, symbolic, philosophical logic), formal semantics, and theorem proving. It is particularly well-suited for:</p> <ul> <li>Students learning logic and educators teaching it</li> <li>Researchers in fields like logic, philosophy, linguistics, computer science, and many others</li> </ul> <p>Documentation: https://digitalformallogic.github.io/mathesis/</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mathesis\n</code></pre>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Interactive theorem proving for humans (proof assistant)</li> <li>Automated reasoning (theorem prover)</li> <li>Define models and check validity of inferences in the models</li> <li>JupyterLab/Jupyter Notebook support</li> <li>Output formulas/proofs in LaTeX</li> <li>Customizable ASCII/Unicode syntax (like <code>A -&gt; B</code>, <code>A \u2192 B</code>, <code>A \u2283 B</code> for the conditional)</li> </ul>"},{"location":"#supported-logics","title":"Supported logics","text":""},{"location":"#propositional-logics","title":"Propositional logics","text":"Truth Table Tableau Natural Deduction Sequent Calculus Classical logic \u2705 \u2705 \u2705 \u2705 Many-valued logics \u2705 - - - Intuitionistic logic n/a - - \u2705"},{"location":"#in-progress","title":"In Progress","text":"<ul> <li>Modal logics</li> <li>Fuzzy logics</li> <li>Substructural logics</li> <li>Epistemic, doxastic, deontic logics</li> <li>Temporal logics</li> </ul>"},{"location":"#first-order-logics-quantified-predicate-logics","title":"First-order logics (quantified, predicate logics)","text":"Model Tableau Natural Deduction Sequent Calculus Classical logic \u2705 \u2705 \u2705 -"},{"location":"#in-progress_1","title":"In Progress","text":"<ul> <li>Many-valued logics</li> <li>Modal logics</li> <li>Intuitionistic logic</li> <li>Fuzzy logics</li> <li>Substructural logics</li> <li>Higher-order logics</li> </ul>"},{"location":"#development-status","title":"Development status","text":""},{"location":"#proof-theories","title":"Proof theories","text":"<ul> <li>Tableaux (semantic tableaux, analytic tableaux)<ul> <li> Unsigned tableaux</li> <li> Signed tableaux</li> </ul> </li> <li>Hilbert systems<ul> <li> Hilbert systems</li> </ul> </li> <li>Natural deduction<ul> <li> Generic natural deduction</li> <li> Gentzen-style natural deduction (Output)</li> <li> Fitch-style natural deduction</li> </ul> </li> <li>Sequent calculi (Gentzen-style sequent calculi)<ul> <li> Two-sided sequent calculi</li> <li> Hilbert systems in sequent calculus</li> <li> Natural deduction in sequent calculus</li> </ul> </li> </ul>"},{"location":"#semantics","title":"Semantics","text":"<ul> <li> Truth tables</li> <li> Set-theoretic models</li> <li> Possible world semantics (Kripke semantics)</li> <li> Algebraic semantics</li> <li> Game-theoretic semantics</li> <li> Category-theoretic semantics</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"alternatives/","title":"Alternatives","text":""},{"location":"alternatives/#nltk","title":"NLTK","text":"<p>NLTK is a Python library for Natural Language Processing, but it includes some logic-related modules:</p> <ul> <li>NLTK :: Sample usage for logic</li> <li>NLTK :: Sample usage for inference</li> <li>NLTK :: Sample usage for resolution</li> <li>NLTK :: Sample usage for nonmonotonic</li> </ul>"},{"location":"alternatives/#pros","title":"Pros","text":"<ul> <li>A mature library with a large community</li> <li>Advanced features</li> </ul>"},{"location":"alternatives/#cons","title":"Cons","text":"<ul> <li>Less flexible syntax</li> <li>Fewer proof methods supported</li> <li>No support for LaTeX output</li> </ul>"},{"location":"alternatives/#others-to-be-added","title":"Others (to be added)","text":"<ul> <li>PyLogics</li> <li>Logic - SymPy</li> <li>tt: logical tools for logic</li> <li>FLiP</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Open an issue or submit a pull request on GitHub digitalformallogic/mathesis.</p>"},{"location":"install/","title":"Installation","text":"<p>Mathesis can be installed from PyPI with pip:</p> <pre><code>pip install mathesis\n</code></pre> <p>To upgrade, add the <code>-U</code> flag:</p> <pre><code>pip install -U mathesis\n</code></pre> <p>Next steps:</p> <ul> <li>To use Mathesis with JupyterLab/Jupyter Notebook, see Use with JupyterLab/Jupyter Notebook</li> </ul>"},{"location":"jupyter/","title":"Use with JupyterLab/Jupyer Notebook","text":"<p>Mathesis works well with JupyterLab and Jupyter notebooks. This is an example of a notebook that uses Mathesis.</p> In\u00a0[1]: Copied! <pre>from IPython.display import display, Math\n</pre> from IPython.display import display, Math In\u00a0[2]: Copied! <pre>from mathesis.deduction.sequent_calculus import SequentTree, rules\nfrom mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\npremises = grammar.parse([\"\u00acA\", \"A\u2228B\"])\nconclusions = grammar.parse([\"B\"])\n</pre> from mathesis.deduction.sequent_calculus import SequentTree, rules from mathesis.grammars import BasicGrammar  grammar = BasicGrammar() premises = grammar.parse([\"\u00acA\", \"A\u2228B\"]) conclusions = grammar.parse([\"B\"]) In\u00a0[3]: Copied! <pre>st = SequentTree(premises, conclusions)\n\nMath(st[1].sequent.latex())\n</pre>  st = SequentTree(premises, conclusions)  Math(st[1].sequent.latex()) Out[3]:  $\\displaystyle \\neg A, A \\lor B \\Rightarrow B$  In\u00a0[4]: Copied! <pre>st.apply(st[1], rules.Negation.Left())\nprint(st.tree())\n</pre> st.apply(st[1], rules.Negation.Left()) print(st.tree()) <pre>\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6\n\n</pre> In\u00a0[5]: Copied! <pre>st.apply(st[5], rules.Disjunction.Left())\nprint(st.tree())\n</pre> st.apply(st[5], rules.Disjunction.Left()) print(st.tree()) <pre>\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n</pre> In\u00a0[6]: Copied! <pre>st.apply(st[9], rules.Weakening.Right())\nprint(st.tree())\n</pre> st.apply(st[9], rules.Weakening.Right()) print(st.tree()) <pre>\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n</pre> In\u00a0[7]: Copied! <pre>st.apply(st[11], rules.Weakening.Right())\nprint(st.tree())\n</pre> st.apply(st[11], rules.Weakening.Right()) print(st.tree()) <pre>\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12 [wR]\n        \u2514\u2500\u2500 B 15 \u21d2 B 16\n\n</pre> In\u00a0[8]: Copied! <pre>print(st.latex())\n</pre> print(st.latex()) <pre>\\begin{prooftree}\n\\AxiomC{$A \\Rightarrow A$}\n\\RightLabel{$wR}\n\\UnaryInfC{$A \\Rightarrow A, B$}\n\\AxiomC{$B \\Rightarrow B$}\n\\RightLabel{$wR}\n\\UnaryInfC{$B \\Rightarrow A, B$}\n\\RightLabel{$\\lor$L}\n\\BinaryInfC{$A \\lor B \\Rightarrow A, B$}\n\\RightLabel{$\\neg$L}\n\\UnaryInfC{$\\neg A, A \\lor B \\Rightarrow B$}\n\\end{prooftree}\n</pre>"},{"location":"usage/automated-reasoning/","title":"Automated Reasoning","text":"<p>Mathesis provides simple solvers (reasoners, provers) based on truth table method and on tableau method.</p>"},{"location":"usage/automated-reasoning/#reasoning-in-propositional-logic","title":"Reasoning in propositional logic","text":""},{"location":"usage/automated-reasoning/#solvers-based-on-truth-table-method","title":"Solvers based on truth table method","text":"<p>See Truth tables.</p>"},{"location":"usage/automated-reasoning/#solvers-based-on-tableau-method","title":"Solvers based on tableau method","text":"<p><code>mathesis.solvers.ClassicalSolver</code> is a solver for classical propositional logic based on tableau method.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.solvers import ClassicalSolver\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"((A \u2192 B)\u2227(A \u2192 C)) \u2192 (A \u2192 (B\u2227C))\")\nsol = ClassicalSolver().solve([], [fml])\n\nprint(sol.htree())\nprint(f\"Valid: {sol.is_valid()}\")\n</code></pre> <pre><code>\u00ac(((A \u2192 B) \u2227 (A \u2192 C)) \u2192 (A \u2192 (B \u2227 C))) 1\n\u2514\u2500\u2500 (A \u2192 B) \u2227 (A \u2192 C) 2\n    \u2514\u2500\u2500 \u00ac(A \u2192 (B \u2227 C)) 3\n        \u2514\u2500\u2500 A \u2192 B 4\n            \u2514\u2500\u2500 A \u2192 C 5\n                \u2514\u2500\u2500 A 6\n                    \u2514\u2500\u2500 \u00ac(B \u2227 C) 7\n                        \u251c\u2500\u2500 \u00acA 8 \u00d7\n                        \u2514\u2500\u2500 B 9\n                            \u251c\u2500\u2500 \u00acA 10 \u00d7\n                            \u2514\u2500\u2500 C 11\n                                \u251c\u2500\u2500 \u00acB 12 \u00d7\n                                \u2514\u2500\u2500 \u00acC 13 \u00d7\n\nValid: True\n</code></pre>"},{"location":"usage/grammars/","title":"Formulas and Grammars","text":""},{"location":"usage/grammars/#parsing-formulas","title":"Parsing formulas","text":"<p>In Mathesis, formulas are represented as objects. Formulas are parsed from strings using grammars (languages, syntax). <code>mathesis.grammars.BasicGrammar</code> is a basic grammar with a standard set of symbols for propositional and quantified logic:</p> <ul> <li><code>\u00ac</code> for negation, <code>\u2227</code> for conjunction, <code>\u2228</code> for disjunction, <code>\u2192</code> for conditional.</li> <li><code>\u22a4</code> for top (True) and <code>\u22a5</code> for bottom (False).</li> <li><code>\u2200</code> for universal quantifier and <code>\u2203</code> for existential quantifier.</li> <li>Arbitrary symbols are allowed for atomic formulas.</li> </ul> <p>For example, <code>\u00ac(A\u2192C)</code> is parsed as a negation of a conditional of two atomic formulas <code>A</code> and <code>C</code>.</p> <pre><code>from mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"\u00ac(A\u2192C)\")\n\nprint(fml, repr(fml))\n</code></pre> <pre><code>\u00ac(A \u2192 C) Neg[Cond[Atom[A], Atom[C]]]\n</code></pre> <p>The <code>symbols</code> option allows you to customize some symbols used in the grammar.</p> <pre><code>from mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar(symbols={\"conditional\": \"\u2283\"})\n\nfml = grammar.parse(\"\u00ac(A\u2283C)\")\n\nprint(fml, repr(fml))\n</code></pre> <pre><code>\u00ac(A \u2192 C) Neg[Cond[Atom[A], Atom[C]]]\n</code></pre> <p>It accepts a list of formulas as well.</p> <pre><code>from mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\n\nfmls = grammar.parse([\"\u00ac(A\u2192C)\", \"B\u2228\u00acB\", \"(((A\u2227B)))\"])\n\nprint([str(fml) for fml in fmls], repr(fmls))\n</code></pre> <pre><code>['\u00ac(A \u2192 C)', 'B \u2228 \u00acB', 'A \u2227 B'] [Neg[Cond[Atom[A], Atom[C]]], Disj[Atom[B], Neg[Atom[B]]], Conj[Atom[A], Atom[B]]]\n</code></pre>"},{"location":"usage/grammars/#advanced","title":"Advanced","text":""},{"location":"usage/grammars/#constructing-formula-objects-directly","title":"Constructing formula objects directly","text":"<p><code>mathesis.forms.Formula</code> is the base class for all formulas.</p> <pre><code>from mathesis.forms import Negation, Conjunction, Disjunction, Conditional, Atom\n\nfml = Negation(Conditional(Atom(\"A\"), Atom(\"C\")))\n\nprint(fml, repr(fml))\n</code></pre> <pre><code>\u00ac(A \u2192 C) Neg[Cond[Atom[A], Atom[C]]]\n</code></pre> <p>New connectives can be defined by subclassing <code>Formula</code>.</p>"},{"location":"usage/grammars/#custom-grammars","title":"Custom grammars","text":"<p>While there is no restriction in the way that a formula string is translated into a formula object, by default Mathesis uses <code>lark</code> for parsing. Using lark, you can define arbitrary grammars in EBNF (Extended Backus-Naur Form) notation. For example, here is a simple grammar for first-order classical logic:</p> <pre><code>from mathesis.grammars import Grammar\n\nclass MyGrammar(Grammar):\n    grammar_rules = r\"\"\"\n?fml: conditional\n    | disjunction\n    | conjunction\n    | negation\n    | universal\n    | particular\n    | top\n    | bottom\n    | atom\n    | \"(\" fml \")\"\n\nPREDICATE: /\\w+/\nTERM: /\\w+/\n\natom : PREDICATE (\"(\" TERM (\",\" TERM)* \")\")?\ntop : \"\u22a4\"\nbottom : \"\u22a5\"\nnegation : \"\u00ac\" fml\nconjunction : fml \"\u2227\" fml\ndisjunction : fml \"\u2228\" fml\nconditional : fml \"\u2192\" fml\nuniversal : \"\u2200\" TERM fml\nparticular : \"\u2203\" TERM fml\n\n%import common.WS\n%ignore WS\n\"\"\".lstrip()\n</code></pre>"},{"location":"usage/kripke/","title":"Possible world (Kripke) semantics","text":"<p>WIP</p>"},{"location":"usage/models/","title":"Set-theoretic Models","text":"In\u00a0[1]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.model import Model\n\ngrammar = BasicGrammar(symbols={\"conditional\": \"\u2192\"})\n\nmodel = Model(\n    domain={\"a\", \"b\", \"c\"},\n    constants={\n        \"a\": \"a\",\n        \"b\": \"b\",\n    },\n    predicates={\n        \"P\": {\"a\", \"b\"},\n        \"Q\": {\"a\"},\n        \"R\": {(\"a\", \"b\"), (\"c\", \"a\")},\n    },\n)\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.model import Model  grammar = BasicGrammar(symbols={\"conditional\": \"\u2192\"})  model = Model(     domain={\"a\", \"b\", \"c\"},     constants={         \"a\": \"a\",         \"b\": \"b\",     },     predicates={         \"P\": {\"a\", \"b\"},         \"Q\": {\"a\"},         \"R\": {(\"a\", \"b\"), (\"c\", \"a\")},     }, ) <p><code>model.valuate()</code> takes a formula and a variable assignment and returns the truth value of the formula in the model.</p> In\u00a0[2]: Copied! <pre>fml = grammar.parse(\"P(a) \u2192 R(x, b)\")\nmodel.valuate(fml, variable_assignment={\"x\": \"c\"})\n</pre> fml = grammar.parse(\"P(a) \u2192 R(x, b)\") model.valuate(fml, variable_assignment={\"x\": \"c\"}) Out[2]: <pre>0</pre> In\u00a0[3]: Copied! <pre>model.valuate(fml, variable_assignment={\"x\": \"a\"})\n</pre> model.valuate(fml, variable_assignment={\"x\": \"a\"}) Out[3]: <pre>1</pre> <p><code>model.validates()</code> takes premises and conclusions and returns whether the model validates the inference.</p> In\u00a0[4]: Copied! <pre>fml = grammar.parse(\"\u2200x(\u2203y((Q(x)\u2228Q(b))\u2192R(x, y)))\")\nmodel.validates(premises=[], conclusions=[fml])\n</pre> fml = grammar.parse(\"\u2200x(\u2203y((Q(x)\u2228Q(b))\u2192R(x, y)))\") model.validates(premises=[], conclusions=[fml]) Out[4]: <pre>True</pre>"},{"location":"usage/models/#models","title":"Models\u00b6","text":"<p>Models can be defined using <code>Model</code> class in <code>mathesis.semantics.model</code>. The class takes four arguments:</p> <ul> <li><code>domain</code>: domain of objects of the model</li> <li><code>constants</code>: a dictionary mapping constant symbols to objects</li> <li><code>predicates</code>: a dictionary mapping predicate symbols to their extensions</li> <li><code>functions</code> (Optional): a dictionary mapping function symbols to functions over the domain</li> </ul>"},{"location":"usage/models/#countermodel-construction","title":"Countermodel construction\u00b6","text":"<p>WIP</p>"},{"location":"usage/natural-deduction/","title":"Proof in Natural Deduction","text":""},{"location":"usage/natural-deduction/#introduction","title":"Introduction","text":"<p>In Mathesis, a state of a natural deduction proof (and its subproofs) consists of the premises and the conclusion that are available to the (sub)proof at a given step. A state is displayed as <code>&lt;premises&gt; \u21d2 &lt;conclusion&gt;</code>.</p> <p>Intuitively, the formulas on the left side of <code>\u21d2</code> are what to come to the upper part of the final (sub)proof, and those on the right side of <code>\u21d2</code> are what to come to the lower part of the final (sub)proof.</p> <p>Natural deduction is a proof system that consists of elimination rules and introduction rules. In Mathesis,</p> <ul> <li>you can apply an elimination rule up-to-down to the premises of a (sub)proof to obtain new premises.</li> <li>Similarly, you can apply an introduction rule down-to-up to the conclusion of a (sub)proof and convert it into new subproofs.</li> </ul> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.natural_deduction import NDTree, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2228B\", \"B\u2192C\"])\nconclusion = grammar.parse(\"A\u2228C\")\nderiv = NDTree(premises, conclusion)\nprint(deriv.tree())\n\nderiv.apply(deriv[1], rules.Disjunction.Elim())\nprint(deriv.tree())\n\nderiv.apply(deriv[8], rules.Disjunction.Intro(\"left\"))\nprint(deriv.tree())\n\nderiv.apply(deriv[10], rules.Conditional.Elim())\nprint(deriv.tree())\n\nderiv.apply(deriv[25], rules.Disjunction.Intro(\"right\"))\nprint(deriv.tree())\n</code></pre> <pre><code>A \u2228 B 1, B \u2192 C 2 \u21d2 A \u2228 C 3\n\nA \u2228 B 1, B \u2192 C 2 \u21d2 A \u2228 C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A \u2228 B 6, B \u2192 C 7 \u21d2 A \u2228 C 8\n\u2514\u2500\u2500 B 5, A \u2228 B 9, B \u2192 C 10 \u21d2 A \u2228 C 11\n\nA \u2228 B 1, B \u2192 C 2 \u21d2 A \u2228 C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A \u2228 B 6, B \u2192 C 7 \u21d2 A \u2228 C 8 [\u2228I]\n\u2502   \u2514\u2500\u2500 A 13, A \u2228 B 14, B \u2192 C 15 \u21d2 A 12\n\u2514\u2500\u2500 B 5, A \u2228 B 9, B \u2192 C 10 \u21d2 A \u2228 C 11\n\nA \u2228 B 1, B \u2192 C 2 \u21d2 A \u2228 C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A \u2228 B 6, B \u2192 C 7 \u21d2 A \u2228 C 8 [\u2228I]\n\u2502   \u2514\u2500\u2500 A 13, A \u2228 B 14, B \u2192 C 15 \u21d2 A 12\n\u2514\u2500\u2500 B 5, A \u2228 B 9, B \u2192 C 10 \u21d2 A \u2228 C 11 [\u2192E]\n    \u251c\u2500\u2500 B 17, A \u2228 B 18, B \u2192 C 19 \u21d2 B 16\n    \u2514\u2500\u2500 C 21, B 22, A \u2228 B 23, B \u2192 C 24 \u21d2 A \u2228 C 25\n\nA \u2228 B 1, B \u2192 C 2 \u21d2 A \u2228 C 3 [\u2228E]\n\u251c\u2500\u2500 A 4, A \u2228 B 6, B \u2192 C 7 \u21d2 A \u2228 C 8 [\u2228I]\n\u2502   \u2514\u2500\u2500 A 13, A \u2228 B 14, B \u2192 C 15 \u21d2 A 12\n\u2514\u2500\u2500 B 5, A \u2228 B 9, B \u2192 C 10 \u21d2 A \u2228 C 11 [\u2192E]\n    \u251c\u2500\u2500 B 17, A \u2228 B 18, B \u2192 C 19 \u21d2 B 16\n    \u2514\u2500\u2500 C 21, B 22, A \u2228 B 23, B \u2192 C 24 \u21d2 A \u2228 C 25 [\u2228I]\n        \u2514\u2500\u2500 C 27, B 28, A \u2228 B 29, B \u2192 C 30 \u21d2 C 26\n</code></pre>"},{"location":"usage/natural-deduction/#first-order-logic","title":"First-order logic","text":"<p>First-order rules are available through dedicated <code>rules.Universal</code> and <code>rules.Particular</code> classes. Just as in standard textbooks, instantiations use a concrete term while generalizations require fresh terms that do not occur elsewhere in the branch.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.natural_deduction import NDTree, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"\u2200x(P(x)\u2192Q(x))\", \"\u2203x P(x)\"])\nconclusion = grammar.parse(\"\u2203x Q(x)\")\n\nderiv = NDTree(premises, conclusion)\nprint(deriv.tree())\n\nderiv.apply(deriv[2], rules.Particular.Elim(\"a\"))\nderiv.apply(deriv[5], rules.Universal.Elim(\"a\"))\nderiv.apply(deriv[8], rules.Conditional.Elim())\nderiv.apply(deriv[24], rules.Particular.Intro(\"a\"))\n\nprint(deriv.tree())\nprint(deriv.tree(style=\"gentzen\"))\n</code></pre> <pre><code>\u2200x(P(x) \u2192 Q(x)) 1, \u2203xP(x) 2 \u21d2 \u2203xQ(x) 3\n\n\u2200x(P(x) \u2192 Q(x)) 1, \u2203xP(x) 2 \u21d2 \u2203xQ(x) 3 [\u2203E]\n\u2514\u2500\u2500 P(a) 4, \u2200x(P(x) \u2192 Q(x)) 5, \u2203xP(x) 6 \u21d2 \u2203xQ(x) 7 [\u2200E]\n    \u2514\u2500\u2500 P(a) \u2192 Q(a) 8, P(a) 9, \u2200x(P(x) \u2192 Q(x)) 10, \u2203xP(x) 11 \u21d2 \u2203xQ(x) 12 [\u2192E]\n        \u251c\u2500\u2500 P(a) \u2192 Q(a) 14, P(a) 15, \u2200x(P(x) \u2192 Q(x)) 16, \u2203xP(x) 17 \u21d2 P(a) 13\n        \u2514\u2500\u2500 Q(a) 19, P(a) \u2192 Q(a) 20, P(a) 21, \u2200x(P(x) \u2192 Q(x)) 22, \u2203xP(x) 23 \u21d2 \u2203xQ(x) 24 [\u2203I]\n            \u2514\u2500\u2500 Q(a) 26, P(a) \u2192 Q(a) 27, P(a) 28, \u2200x(P(x) \u2192 Q(x)) 29, \u2203xP(x) 30 \u21d2 Q(a) 25\n\n\u2203xQ(x) [\u2203E]\n\u251c\u2500\u2500 \u2203xP(x)\n\u2514\u2500\u2500 \u2203xQ(x) [\u2203I]\n    \u2514\u2500\u2500 Q(a) [\u2192E]\n        \u251c\u2500\u2500 P(a) \u2192 Q(a) [\u2200E]\n        \u2502   \u2514\u2500\u2500 \u2200x(P(x) \u2192 Q(x))\n        \u2514\u2500\u2500 P(a)\n</code></pre>"},{"location":"usage/natural-deduction/#render-as-gentzen-style-proof","title":"Render as Gentzen-style proof","text":"<p>(WIP) Mathesis has an experimental support for rendering a natural deduction proof as a Gentzen-style proof or its LaTeX code.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.natural_deduction import NDTree, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2228B\", \"B\u2192C\"])\nconclusion = grammar.parse(\"A\u2228C\")\nderiv = NDTree(premises, conclusion)\nprint(deriv.tree(number=False))\n\nderiv.apply(deriv[1], rules.Disjunction.Elim())\nderiv.apply(deriv[8], rules.Disjunction.Intro(\"left\"))\nderiv.apply(deriv[10], rules.Conditional.Elim())\nderiv.apply(deriv[25], rules.Disjunction.Intro(\"right\"))\n\nprint(deriv.tree(style=\"gentzen\"))\n\nprint(deriv.latex())\n</code></pre> <pre><code>A \u2228 B, B \u2192 C \u21d2 A \u2228 C\n\nA \u2228 C [\u2228E]\n\u251c\u2500\u2500 A \u2228 C [\u2228I]\n\u2502   \u2514\u2500\u2500 A\n\u251c\u2500\u2500 A \u2228 C [\u2228I]\n\u2502   \u2514\u2500\u2500 C [\u2192E]\n\u2502       \u251c\u2500\u2500 B \u2192 C\n\u2502       \u2514\u2500\u2500 B\n\u2514\u2500\u2500 A \u2228 B\n\n\\begin{prooftree}\n\\AxiomC{$[A]$}\n\\RightLabel{$\\lor$I}\n\\UnaryInfC{$A \\lor C$}\n\\AxiomC{$B \\to C$}\n\\AxiomC{$[B]$}\n\\RightLabel{$\\to$E}\n\\BinaryInfC{$C$}\n\\RightLabel{$\\lor$I}\n\\UnaryInfC{$A \\lor C$}\n\\AxiomC{$A \\lor B$}\n\\RightLabel{$\\lor$E}\n\\TrinaryInfC{$A \\lor C$}\n\\end{prooftree}\n</code></pre> \\[ \\begin{prooftree} \\AxiomC{$[A]$} \\RightLabel{$\\lor$I} \\UnaryInfC{$A \\lor C$} \\AxiomC{$B \\to C$} \\AxiomC{$[B]$} \\RightLabel{$\\to$E} \\BinaryInfC{$C$} \\RightLabel{$\\lor$I} \\UnaryInfC{$A \\lor C$} \\AxiomC{$A \\lor B$} \\RightLabel{$\\lor$E} \\TrinaryInfC{$A \\lor C$} \\end{prooftree} \\]"},{"location":"usage/natural-deduction/#render-as-fitch-style-proof","title":"Render as Fitch-style proof","text":"<p>WIP</p>"},{"location":"usage/natural-deduction/#render-as-suppes-lemmon-style-proof","title":"Render as Suppes-Lemmon-style proof","text":"<p>WIP</p>"},{"location":"usage/natural-deduction/#render-as-sequent-calculus-proof","title":"Render as Sequent Calculus proof","text":"<p>WIP</p>"},{"location":"usage/sequent-calculi/","title":"Proof in Sequent Calculus","text":"<p>Sequent calculus (plural: calculi) is a formal proof system based on sequents, which normally are expressions of the form \\(\\Gamma \\vdash \\Delta\\), where \\(\\Gamma\\) and \\(\\Delta\\) are lists or sets of formulas.</p>"},{"location":"usage/sequent-calculi/#sequent-trees-and-applications-of-rules","title":"Sequent trees and applications of rules","text":"<p><code>mathesis.deduction.sequent_calculus.SequentTree</code> is a class for sequent trees (proof trees, proof diagrams). It is initialized with an inference, given as a list of premises and of conclusions. Rules are applied to a sequent in a sequent tree with <code>st.apply(node, rule)</code> where <code>st</code> is a sequent tree.</p> <pre><code>from mathesis.deduction.sequent_calculus import SequentTree, rules\nfrom mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\npremises = grammar.parse([\"\u00acA\", \"A\u2228B\"])\nconclusions = grammar.parse([\"B\"])\n\nst = SequentTree(premises, conclusions)\n\nprint(st.tree())\nst.apply(st[1], rules.Negation.Left())\nprint(st.tree())\nst.apply(st[5], rules.Disjunction.Left())\nprint(st.tree())\nst.apply(st[9], rules.Weakening.Right())\nprint(st.tree())\nst.apply(st[12], rules.Weakening.Right())\nprint(st.tree())\n</code></pre> <pre><code>\u00acA 1, A \u2228 B 2 \u21d2 B 3\n\n\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6\n\n\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12\n\n\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12 [wR]\n        \u2514\u2500\u2500 B 15 \u21d2 A 16\n</code></pre>"},{"location":"usage/sequent-calculi/#render-the-proof-in-latex","title":"Render the proof in LaTeX","text":"<p>A sequent tree object can be rendered in LaTeX with <code>st.latex()</code>. The LaTeX output uses a <code>prooftree</code> environment of <code>bussproofs</code> package. MathJax supports <code>bussproofs</code> package, so you can render the LaTeX output on a Web page.</p> <pre><code>from mathesis.deduction.sequent_calculus import SequentTree, rules\nfrom mathesis.grammars import BasicGrammar\n\ngrammar = BasicGrammar()\npremises = grammar.parse([\"\u00acA\", \"A\u2228B\"])\nconclusions = grammar.parse([\"B\"])\n\nst = SequentTree(premises, conclusions)\n\nprint(st.tree())\nprint(st.latex(number=False), \"\\n\")\n\nst.apply(st[1], rules.Negation.Left())\n# print(st.tree())\nst.apply(st[5], rules.Disjunction.Left())\n# print(st.tree())\nst.apply(st[9], rules.Weakening.Right())\n# print(st.tree())\nst.apply(st[12], rules.Weakening.Right())\nprint(st.tree())\nprint(st.latex(number=False))\n</code></pre> <pre><code>\u00acA 1, A \u2228 B 2 \u21d2 B 3\n\n\\begin{prooftree}\n\\AxiomC{$\\neg A, A \\lor B \\Rightarrow B$}\n\\end{prooftree} \n\n\u00acA 1, A \u2228 B 2 \u21d2 B 3 [\u00acL]\n\u2514\u2500\u2500 A \u2228 B 5 \u21d2 A 4, B 6 [\u2228L]\n    \u251c\u2500\u2500 A 7 \u21d2 A 8, B 9 [wR]\n    \u2502   \u2514\u2500\u2500 A 13 \u21d2 A 14\n    \u2514\u2500\u2500 B 10 \u21d2 A 11, B 12 [wR]\n        \u2514\u2500\u2500 B 15 \u21d2 A 16\n\n\\begin{prooftree}\n\\AxiomC{$A \\Rightarrow A$}\n\\RightLabel{$wR}\n\\UnaryInfC{$A \\Rightarrow A, B$}\n\\AxiomC{$B \\Rightarrow A$}\n\\RightLabel{$wR}\n\\UnaryInfC{$B \\Rightarrow A, B$}\n\\RightLabel{$\\lor$L}\n\\BinaryInfC{$A \\lor B \\Rightarrow A, B$}\n\\RightLabel{$\\neg$L}\n\\UnaryInfC{$\\neg A, A \\lor B \\Rightarrow B$}\n\\end{prooftree}\n</code></pre> \\[ \\begin{prooftree} \\AxiomC{$\\neg A, A \\lor B \\Rightarrow B$} \\end{prooftree} \\] \\[ \\begin{prooftree} \\AxiomC{$A \\Rightarrow A$} \\RightLabel{wR} \\UnaryInfC{$A \\Rightarrow A, B$} \\AxiomC{$B \\Rightarrow A$} \\RightLabel{wR} \\UnaryInfC{$B \\Rightarrow A, B$} \\RightLabel{$\\lor$L} \\BinaryInfC{$A \\lor B \\Rightarrow A, B$} \\RightLabel{$\\neg$L} \\UnaryInfC{$\\neg A, A \\lor B \\Rightarrow B$} \\end{prooftree} \\]"},{"location":"usage/tableaux/","title":"Proof in Tableau","text":"<p>Semantic tableau (plural: tableaux) is a decision/proof procedure for propositional and quantified logics.</p>"},{"location":"usage/tableaux/#unsigned-tableaux","title":"Unsigned tableaux","text":"<p><code>mathesis.deduction.tableau.Tableau</code> is a class for unsigned tableaux. It is initialized with an inference, given as a list of premises and of conclusions.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import Tableau\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2192B\", \"B\u2192C\"])\nconclusions = grammar.parse([\"A\u2192C\"])\ntab = Tableau(premises, conclusions)\n\nprint(tab.htree())\n</code></pre> <pre><code>A \u2192 B 1\n\u2514\u2500\u2500 B \u2192 C 2\n    \u2514\u2500\u2500 \u00ac(A \u2192 C) 3\n</code></pre> <p>A tableau is a tree of nodes, each node being a formula. Mathesis automatically indexes the nodes, so that you can access them by their index. You can apply a rule to a node of tableau with <code>tab.apply(node, rule)</code> where <code>tab</code> is a tableau:</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import Tableau, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2192B\", \"B\u2192C\"])\nconclusions = grammar.parse([\"A\u2192C\"])\ntab = Tableau(premises, conclusions)\n\nprint(tab.htree())\nprint(f\"Closed: {tab.is_closed()}\\n\")\n\ntab.apply(tab[3], rules.NegatedConditionalRule())\nprint(tab.htree())\ntab.apply(tab[1], rules.ConditionalRule())\nprint(tab.htree())\ntab.apply(tab[2], rules.ConditionalRule())\nprint(tab.htree())\n\nprint(f\"Closed: {tab.is_closed()}\")\n</code></pre> <pre><code>A \u2192 B 1\n\u2514\u2500\u2500 B \u2192 C 2\n    \u2514\u2500\u2500 \u00ac(A \u2192 C) 3\n\nClosed: False\n\nA \u2192 B 1\n\u2514\u2500\u2500 B \u2192 C 2\n    \u2514\u2500\u2500 \u00ac(A \u2192 C) 3\n        \u2514\u2500\u2500 A 4\n            \u2514\u2500\u2500 \u00acC 5\n\nA \u2192 B 1\n\u2514\u2500\u2500 B \u2192 C 2\n    \u2514\u2500\u2500 \u00ac(A \u2192 C) 3\n        \u2514\u2500\u2500 A 4\n            \u2514\u2500\u2500 \u00acC 5\n                \u251c\u2500\u2500 \u00acA 6 \u00d7\n                \u2514\u2500\u2500 B 7\n\nA \u2192 B 1\n\u2514\u2500\u2500 B \u2192 C 2\n    \u2514\u2500\u2500 \u00ac(A \u2192 C) 3\n        \u2514\u2500\u2500 A 4\n            \u2514\u2500\u2500 \u00acC 5\n                \u251c\u2500\u2500 \u00acA 6 \u00d7\n                \u2514\u2500\u2500 B 7\n                    \u251c\u2500\u2500 \u00acB 8 \u00d7\n                    \u2514\u2500\u2500 C 9 \u00d7\n\nClosed: True\n</code></pre> <p>A branch is a path from the root to a leaf of the tableau. A branch is closed if it contains a contradiction (i.e., contradictory formulas.) The tableau is closed if all branches are closed.</p>"},{"location":"usage/tableaux/#signed-tableaux","title":"Signed tableaux","text":"<p>A signed tableau is a tableau where each node is signed with a truth value.</p> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import SignedTableau, signed_rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"A\u2192B\", \"B\u2192C\"])\nconclusions = grammar.parse([\"A\u2192C\"])\ntab = SignedTableau(premises, conclusions)\n\nprint(tab.htree())\n</code></pre> <pre><code>True A \u2192 B 1\n\u2514\u2500\u2500 True B \u2192 C 2\n    \u2514\u2500\u2500 False A \u2192 C 3\n</code></pre>"},{"location":"usage/tableaux/#first-order-logic","title":"First-order logic","text":"<p>In first-order logic, the rules extend to quantifiers as follows:</p>"},{"location":"usage/tableaux/#unsigned-tableaux_1","title":"Unsigned tableaux","text":"<ul> <li><code>NegatedParticularRule</code></li> <li><code>NegatedUniversalRule</code></li> <li><code>UniversalInstantiationRule</code></li> <li><code>ParticularInstantiationRule</code></li> </ul> <pre><code>from mathesis.grammars import BasicGrammar\nfrom mathesis.deduction.tableau import Tableau, rules\n\ngrammar = BasicGrammar()\n\npremises = grammar.parse([\"P(a)\", \"\u2200x(P(x)\u2192Q(x))\"])\nconclusions = grammar.parse([\"Q(a)\"])\ntab = Tableau(premises, conclusions)\n\nprint(tab.htree())\nprint(f\"Closed: {tab.is_closed()}\\n\")\n\ntab.apply(tab[2], rules.UniversalInstantiationRule(replacing_term=\"a\"))\nprint(tab.htree())\n\ntab.apply(tab[4], rules.ConditionalRule())\nprint(tab.htree())\n\nprint(f\"Closed: {tab.is_closed()}\\n\")\n</code></pre> <pre><code>P(a) 1\n\u2514\u2500\u2500 \u2200x(P(x) \u2192 Q(x)) 2\n    \u2514\u2500\u2500 \u00acQ(a) 3\n\nClosed: False\n\nP(a) 1\n\u2514\u2500\u2500 \u2200x(P(x) \u2192 Q(x)) 2\n    \u2514\u2500\u2500 \u00acQ(a) 3\n        \u2514\u2500\u2500 P(a) \u2192 Q(a) 4\n\nP(a) 1\n\u2514\u2500\u2500 \u2200x(P(x) \u2192 Q(x)) 2\n    \u2514\u2500\u2500 \u00acQ(a) 3\n        \u2514\u2500\u2500 P(a) \u2192 Q(a) 4\n            \u251c\u2500\u2500 \u00acP(a) 5 \u00d7\n            \u2514\u2500\u2500 Q(a) 6 \u00d7\n\nClosed: True\n</code></pre>"},{"location":"usage/tableaux/#signed-tableaux_1","title":"Signed tableaux","text":"<p>WIP</p>"},{"location":"usage/tableaux/#further-reading","title":"Further reading","text":"<p>See Automated reasoning for automated reasoning with tableaux.</p>"},{"location":"usage/truth-tables/","title":"Truth Tables","text":"In\u00a0[1]: Copied! <pre>from mathesis.system.classical.truth_table import ConditionalClause\n\nconditional_clause = ConditionalClause()\nconditional_clause\n</pre> from mathesis.system.classical.truth_table import ConditionalClause  conditional_clause = ConditionalClause() conditional_clause Out[1]: P Q Conditional(P, Q) 1 1 1 1 0 0 0 1 1 0 0 1 <p>Outside Jupyer, you get a plain text table:</p> In\u00a0[2]: Copied! <pre>print(conditional_clause)\n</pre> print(conditional_clause) <pre>P        Q        Conditional(P, Q)        \n1        1                1                \n1        0                0                \n0        1                1                \n0        0                1                \n</pre> In\u00a0[3]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import ClassicalTruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"(\u00acP\u2227(P\u2228Q))\u2192Q\")\n\ntable = ClassicalTruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import ClassicalTruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"(\u00acP\u2227(P\u2228Q))\u2192Q\")  table = ClassicalTruthTable(fml) table Out[3]: P Q \u00acP P \u2228 Q \u00acP \u2227 (P \u2228 Q) (\u00acP \u2227 (P \u2228 Q)) \u2192 Q 0 0 1 0 0 1 0 1 1 1 1 1 1 0 0 1 0 1 1 1 0 1 0 1 <p><code>table.is_valid()</code> just returns whether the formula is valid.</p> In\u00a0[4]: Copied! <pre>f\"Valid: {table.is_valid()}\"\n</pre> f\"Valid: {table.is_valid()}\" Out[4]: <pre>'Valid: True'</pre> In\u00a0[5]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import K3TruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"A\u2228\u00acA\")\n\ntable = K3TruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import K3TruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"A\u2228\u00acA\")  table = K3TruthTable(fml) table Out[5]: A \u00acA A \u2228 \u00acA i i i 0 1 1 1 0 1 In\u00a0[6]: Copied! <pre>f\"Valid: {table.is_valid()}\"\n</pre> f\"Valid: {table.is_valid()}\" Out[6]: <pre>'Valid: False'</pre> In\u00a0[7]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import L3TruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"A\u2192A\")\n\ntable = L3TruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import L3TruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"A\u2192A\")  table = L3TruthTable(fml) table Out[7]: A A \u2192 A i 1 0 1 1 1 In\u00a0[8]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import LPTruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")\n\ntable = LPTruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import LPTruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")  table = LPTruthTable(fml) table Out[8]: A \u00acA A \u2227 \u00acA (A \u2227 \u00acA) \u2192 A 0 1 0 1 1 0 0 1 i i i i In\u00a0[9]: Copied! <pre>f\"Valid: {table.is_valid()}\"\n</pre> f\"Valid: {table.is_valid()}\" Out[9]: <pre>'Valid: True'</pre> In\u00a0[10]: Copied! <pre>from mathesis.grammars import BasicGrammar\nfrom mathesis.semantics.truth_table import FDETruthTable\n\ngrammar = BasicGrammar()\n\nfml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")\n\ntable = FDETruthTable(fml)\ntable\n</pre> from mathesis.grammars import BasicGrammar from mathesis.semantics.truth_table import FDETruthTable  grammar = BasicGrammar()  fml = grammar.parse(\"(A\u2227\u00acA)\u2192A\")  table = FDETruthTable(fml) table Out[10]: A \u00acA A \u2227 \u00acA (A \u2227 \u00acA) \u2192 A i i i i 0 1 0 1 b b b b 1 0 0 1"},{"location":"usage/truth-tables/#truth-tables","title":"Truth tables\u00b6","text":""},{"location":"usage/truth-tables/#show-truth-tables-for-connectives","title":"Show truth tables for connectives\u00b6","text":"<p>Truth functions are defined as clauses in mathesis. You can show the truth tables for the clauses in HTML in JupyerLab/Jupyter Notebook:</p>"},{"location":"usage/truth-tables/#generate-truth-tables-for-classical-logic","title":"Generate truth tables for classical logic\u00b6","text":"<p><code>mathesis.semantics.truth_table.ClassicalTruthTable</code> automatically generates the truth table for a given formula.</p>"},{"location":"usage/truth-tables/#generate-truth-tables-for-many-valued-logics","title":"Generate truth tables for many-valued logics\u00b6","text":"<p>Some many-valued logics are implemented out of the box. They are available from <code>mathesis.semantics.truth_table</code>.</p>"},{"location":"usage/truth-tables/#three-valued-logic-k3-and-3","title":"Three-valued logic K<sub>3</sub> and \u0141<sub>3</sub>\u00b6","text":""},{"location":"usage/truth-tables/#kleenes-k3","title":"Kleene's K<sub>3</sub>\u00b6","text":""},{"location":"usage/truth-tables/#ukasiewiczs-3","title":"\u0141ukasiewicz's \u0141<sub>3</sub>\u00b6","text":""},{"location":"usage/truth-tables/#three-valued-logic-lp","title":"Three-valued logic LP\u00b6","text":""},{"location":"usage/truth-tables/#four-valued-logic-fde","title":"Four-valued logic FDE\u00b6","text":""},{"location":"usage/truth-tables/#use-custom-symbols-for-truth-values","title":"Use custom symbols for truth values\u00b6","text":"<p>Subclasses of <code>ConnectiveClause()</code> and <code>TruthTable()</code> can have <code>truth_value_symbols</code> attribute that is a dictionary mapping internal numeric truth values to arbitrary symbols like \u22a4, \u22a5, T, F, etc.</p>"},{"location":"usage/truth-tables/#define-custom-truth-tables","title":"Define custom truth tables\u00b6","text":"<p>WIP</p>"}]}